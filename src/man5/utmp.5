.\" Copyright (c) 1993 Michael Haardt (michael@cantor.informatik.rwth-aachen.de), Fri Apr  2 11:32:09 MET DST 1993
.\" 
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\" 
.\" The GNU General Public Licensès references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\" 
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\" 
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\" 
.\" Modified 1993-07-25 by Rik Faith (faith@cs.unc.edu)
.\" Modified 1995-02-26 by Michael Haardt
.\" Modified 1996-07-20 by Michael Haardt
.\" Modified 1997-07-02 by Nicolás Lichtmaier <nick@debian.org>
.\" Modified 2004-10-31 by aeb, following Gwenole Beauchesne
.\" 
.\" Traduzione in italiano di Giovanni Bortolozzo <borto@dei.unipd.it>
.\" Settembre 1996
.\" Aggiornamento a man-pages-1.15 di Alessandro Rubini (rubini@linux.it)
.\" Febbraio 1998
.\" Aggiornamento a man-pages-1.20 di Ottavio G. Rizzo (otto@mast.queensu.ca)
.\" Giugno 1998
.\" Aggiornamento a man-pages-2.11 di Giulio Daprelà <giulio@pluto.it>
.\" novembre 2005
.\" Aggiornamento a man-pages-2.57 di Elisabetta Galli <lab@kkk.it>
.\" luglio 2007
.\" Aggiornamento a man-pages-3.12 di Elisabetta Galli <lab@kkk.it>
.\" novembre 2008
.\" 
.TH "UTMP" "5" "10 ottobre 2008" "Linux " "Linux Programmer's Manual"
.SH "NOME"
utmp, wtmp \- registri dei login
.SH "SINTASSI"
.B #include <utmp.h>
.SH "DESCRIZIONE"
Il file
.I utmp
permette di scoprire informazioni su chi sta usando attualmente il
sistema.
Ci possono essere più utenti che stanno usando il sistema di quelli riportati,
poiché non tutti i programmi usano registrazioni utmp.
.PP 
.B Attenzione:
.I utmp
non deve essere scrivibile dalla classe di utenti "others",
poiché molti programmi di sistema dipendono (stupidamente)
dalla sua integrità.
Si rischia di avere file di log contraffatti 
e file di sistema modificati lasciando
.I utmp
scrivibile da utenti che non siano il proprietario o il gruppo proprietario del file.
.PP 
Il file è una sequenza di
strutture
.I utmp ,
dichiarate nel modo seguente in
.I R <utmp.h>
(si noti che questa è solo una delle numerose
definizioni in giro; i dettagli dipendono dalla versione di libc):
.in +4n
.nf 
.sp
/* Values for ut_type field, below */

#define EMPTY         0 /* Il record non contiene informazioni valide
                           (precedentemente conosciuto come UT_UNKNOWN su Linux) */
#define RUN_LVL       1 /* Cambiamento nel run\-level di sistema (vedere
                           \fBinit\fP(8) */
#define BOOT_TIME     2 /* Tempo di avvio del sistema (in \fIut_tv\fP) */
#define NEW_TIME      3 /* Tempo dopo il cambiamento dell'orologio di sistema
                           (in \fIut_tv\fP) */
#define OLD_TIME      4 /* Tempo prima del cambiamento dell'orologio di sistema
                           (in \fIut_tv\fP) */
#define INIT_PROCESS  5 /* Processo rigenerato da \fBinit\fP(8) */
#define LOGIN_PROCESS 6 /* Processo leader della sessione per il login dell'utente */
#define USER_PROCESS  7 /* Processo normale */
#define DEAD_PROCESS  8 /* Processo terminato */
#define ACCOUNTING    9 /* Non implementato */

#define UT_LINESIZE     32
#define UT_NAMESIZE     32
#define UT_HOSTSIZE    256

struct exit_status {              /* Tipo per ut_exit, sotto */
  short int e_termination;        /* stato di chiusura del processo */
  short int e_exit;               /* stato di uscita del processo */
};

struct utmp {
  short ut_type;              /* tipo di record */
  pid_t ut_pid;               /* PID del processo di login */
  char ut_line[UT_LINESIZE];  /* nome del dispositivo tty \- "/dev/" */
  char ut_id[4];              /* suffisso del nome del terminale,
                                 o ID inittab(5) */
  char ut_user[UT_NAMESIZE];  /* nome utente */
  char ut_host[UT_HOSTSIZE];  /* nome dell'host per il login remoto, o
                                 versione del kernel per i messaggi di
                                 run\-level*/
  struct exit_status ut_exit; /* stato di uscita di un processo
                                 marcato come DEAD_PROCESS. Non usato
                                 dal programma init(8) di Linux */
  /* I campi ut_session e ut_tv devono essere della stessa dimensione sia
     compilati per 32 che per 64 bit. Ciò permette a file dati e memoria
     condivisa di essere condivisi tra applicazioni 32\-bit e applicazioni 64\-bit. */
#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
  int32_t ut_session;         /* ID della sessione (\fBgetsid\fP(2)),
                                 usato per il windowing */
  struct {
    int32_t tv_sec;           /* secondi */
    int32_t tv_usec;          /* microsecondi */
  } ut_tv;                    /* creata una voce Time */
#else
   long int ut_session;        /* ID della sessione */
   struct timeval ut_tv;       /* creata una voce Time */
#endif

  int32_t ut_addr_v6[4];       /* indirizzo IP dell'host
                                  remoto. Gli indirizzi IPv4 usano
                                  solo ut_addr_v6[0] */
  char __unused[20];           /* riservato per usi futuri */
};

/* Trucchi per la compatibilità all'indietro.  */
#define ut_name ut_user
#ifndef _NO_UT_TIME
#define ut_time ut_tv.tv_sec
#endif
#define ut_xtime ut_tv.tv_sec
#define ut_addr ut_addr_v6[0]
.sp
.fi 
.in
Questa struttura dà il nome del file speciale associato al
terminale utente, il nome di login dell'utente, e l'ora di login
nel formato di 
.BR time (2).
I campi stringa sono terminati con \fB\/aq\e0\(aq\fP
se sono più corti della
dimensione del campo.
.PP 
Le prime voci del file sono il risultato di
.BR init (8)
quando processa
.BR inittab (5).
Prima che una voce sia eseguita, però,
.BR init (8)
pulisce il file utmp assegnando il valore di \fBDEAD_PROCESS\fP a \fIut_type\fP,
pulendo \fIut_user\fP, \fIut_host\fP e \fIut_time\fP con byte nulli per ogni
registrazione il cui \fIut_type\fP non sia \fIDEAD_PROCESS\fP o \fIRUN_LVL\fP, e
quelle per cui non esistono processi con PID \fIut_pid\fP.
Se non si trovano registrazioni vuote con la
\fIut_id\fP necessaria,
.BR init(8)
ne crea una nuova.
Poi assegna \fIut_id\fP dal file inittab, assegna i valori attuali a \fIut_pid\fP
e \fIut_time\fP e assegna \fBINIT_PROCESS\fP a \fIut_type\fP.
.PP 
.BR mingetty (8)
(o
.BR agetty (8))
localizza le voci tramite il PID, cambia \fIut_type\fP perché
contenga \fBLOGIN_PROCESS\fP, aggiorna \fIut_time\fP, assegna \fIut_line\fP e
aspetta che venga stabilita una connessione.
.BR login (1),
dopo aver autenticato un utente,
cambia \fIut_type\fP perché valga \fBUSER_PROCESS\fP, aggiorna
\fIut_time\fP e imposta \fIut_host\fP e \fIut_addr\fP.
In base al comportamento di
.BR mingetty (8)
(o
.BR agetty (8))
e
.BR login (1),
i record possono essere indirizzati da
\fIut_line\fP invece del metodo preferibile, \fIut_pid\fP.
.PP 
Quando
.BR init (8)
scopre che un processo è terminato, ricerca la sua voce utmp tramite \fIut_pid\fP,
assegna il valore \fBDEAD_PROCESS\fP a \fIut_type\fP e pulisce \fIut_user\fP,
\fIut_host\fP e \fIut_time\fP, assegnandogli dei byte nulli.
.PP 
.BR xterm (1)
e altri emulatori terminale creano direttamente un record
\fBUSER_PROCESS\fP e generano il \fIut_id\fP usando la stringa che compone
il suffisso finale del nome del terminale (i caratteri che
seguono \fI/dev/[pt]ty\fP.
Se trovano un \fBDEAD_PROCESS\fP per questo ID
lo riciclano, altrimenti creano una nuova voce.
Se possono, lo
marcheranno come \fBDEAD_PROCESS\fP all'uscita e si consiglia che
azzerino anche \fIut_line\fP, \fIut_time\fP, \fIut_user\fP e
\fIut_host\fP.
.PP 
.BR telnetd (8)
imposta una voce \fBLOGIN_PROCESS\fP e lascia il resto a
.BR login (1)
come al solito.
Dopo che la sessione telnet termina
.BR telnetd (8)
pulisce utmp nel modo descritto.
.PP 
Il file \fIwtmp\fP registra tutti i login e logout.
Il suo formato è esattamente come \fIutmp\fP tranne che un nome utente nullo
indica un logout
sul terminale associato.
Inoltre il nome terminale \fB~\fP
con nome utente \fBshutdown\fP o \fBreboot\fP indica uno spegnimento o
riavvio del sistema e la coppia di nomi di terminale \fB|\fP/\fB}\fP
registra la vecchia/nuova ora di sistema quando
.BR date (1)
la cambia.
\fIwtmp\fP è mantenuto da
.BR login (1),
.BR init (8),
e da alcune versioni di
.BR getty (8)
(cioè
.BR mingetty (8)
o
.BR agetty (8)).
Il file non è creato da nessuno di questi programmi, quindi se esso 
viene rimosso la registrazione è disattivata.
.SH "FILE"
/var/run/utmp
.br 
/var/log/wtmp
.SH "CONFORME A"
.PP 
POSIX.1 non specifica una struttura
.I utmp
ma una che si chiama
.I R utmpx ,
con specifiche per i campi
.I R ut_type ,
.I R ut_pid ,
.I R ut_line ,
.I R ut_id ,
.I R ut_user ,
e
.I R ut_tv .
POSIX.1 non specifica la lunghezza dei
campi
.I ut_line
e
.I ut_user.

Linux definisce la struttura
.I utmpx
uguale a quella di
.I utmp.

.SS Confronto tra sistemi storici
Le voci Linux utmp non sono conformi nè a v7/BSD nè a SYSV; esse sono un
mix delle due.

v7/BSD ha meno campi; più importante, esso non ha
\fIut_type\fP, e ciò fa sì che programmi nativi v7/BSD visualizzino (per
esempio) voci morte o di login.
Inoltre, non c'è alcun file di configurazione
che alloca spazi alle sessioni.
BSD fa questo perché non ha campi \fIut_id\fP.

In Linux (come in System V), il campo \fIut_id\fP di un
record non cambierà mai una volta che è stato impostato, e ciò riserva 
questo spazio senza bisogno di un file di configurazione.
Cancellare \fIut_id\fP può dar luogo a
delle race condition che portano a voci utmp corrotte e a potenziali
buchi di sicurezza.
Cancellare i campi menzionati sopra riempiendoli
con byte nulli non è richiesto dalla semantica System V,
ma permette di eseguire
molti programmi che assumono la semantica BSD e che non modificano utmp.
Linux usa le convenzioni BSD per i contenuti di linea, come documentato in precedenza.
.PP 
.\" mtk: a cosa si riferisce "them" nella frase che segue?
.\" System V usa solo il campo type per marcarle e registra
.\" messaggi informativi come, per esempio, \fB"new time"\fP nel campo line.
System V non ha campi \fIut_host\fP o \fIut_addr_v6\fP.
.SH "NOTE"
.PP 
A differenza di vari
altri sistemi, in cui la registrazione in utmp può essere disabilitata cancellando il
file, utmp deve sempre esistere in Linux.
Se si vuole disabilitare
.BR who (1)
basta togliere il permesso di lettura globale al file utmp.
.PP 
Il formato del file dipende dalla macchina, perciò si raccomanda di processarlo solo
su macchine con la stessa architettura di quella su cui il file è stato creato.
.PP 
Notare che su piattaforme \fIbiarch\fP, cioé sistemi che possono far 
girare sia applicazioni 32\-bit che 64\-bit (x86\-64, ppc64, s390x, etc.),
\fIut_tv\fP è della stessa dimensione in modo 32\-bit e in modo 64\-bit.
Lo stesso vale per \fIut_session\fP e \fIut_time\fP se sono presenti.
Ciò permette a file dati e memoria condivisa di essere condivisi tra
applicazioni 32\-bit e applicazioni 64\-bit.
Ciò si ottiene cambiando il tipo di
.I ut_session
a
.I R int32_t ,
e il tipo di
.I ut_tv
ad una struttura con due
campi
.I int32_t, 
.I tv_sec
e
.I R tv_usec .
Poiché \fIut_tv\fP potrebbe non essere lo stesso di \fIstruct timeval\fP,
invece della chiamata:
.in +4n
.nf 
.sp
gettimeofday((struct timeval *) &ut.ut_tv, NULL);
.fi 
.in

si raccomanda il seguente metodo per impostare il campo:
.in +4n
.nf 
.sp
struct utmp ut;
struct timeval tv;

gettimeofday(&tv, NULL);
ut.ut_tv.tv_sec = tv.tv_sec;
ut.ut_tv.tv_usec = tv.tv_usec;
.fi 
.in
.PP 
Si noti che lo struct di \fIutmp\fP è cambiato in libc6.
Di conseguenza, 
un programma che usi il vecchio struct di libc5 altera
.I R /var/run/utmp " o " /var/log/wtmp .
.SH "BUG"
Questa pagina di manuale si basa su quella di libc5, ora le cose potrebbero funzionare diversamente.
.SH "VEDERE ANCHE"
.BR ac (1),
.BR date (1),
.BR last (1),
.BR login (1),
.BR who (1),
.BR getutent (3),
.BR getutmp (3),
.BR login (3),
.BR logout (3),
.BR logwtmp (3),
.BR updwtmp (3),
.BR init (8)
.SH "COLOPHON"
Questa pagina fa parte del rilascio 3.12 del progetto
.I man\-pages
di Linux.
Si può trovare una descrizione del progetto,
e informazioni su come riportare bachi,
presso
http://www.kernel.org/doc/man\-pages/.
Per la traduzione in italiano si può fare riferimento a
http://www.pluto.it/ildp/collaborare/
