'\" t
.\" Copyright (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\" and Copyright (c) 2002,2006 by Michael Kerrisk <mtk-manpages@gmx.net>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified Sat Jul 24 17:34:08 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified Sun Jan  7 01:41:27 1996 by Andries Brouwer (aeb@cwi.nl)
.\" Modified Sun Apr 14 12:02:29 1996 by Andries Brouwer (aeb@cwi.nl)
.\" Modified Sat Nov 13 16:28:23 1999 by Andries Brouwer (aeb@cwi.nl)
.\" Modified 10 Apr 2002, by Michael Kerrisk <mtk-manpages@gmx.net>
.\" Modified  7 Jun 2002, by Michael Kerrisk <mtk-manpages@gmx.net>
.\"	Added information on real-time signals
.\" Modified 13 Jun 2002, by Michael Kerrisk <mtk-manpages@gmx.net>
.\"	Noted that SIGSTKFLT is in fact unused
.\" 2004-12-03, Modified mtk, added notes on RLIMIT_SIGPENDING
.\" 2006-04-24, mtk, Added text on changing signal dispositions,
.\"		signal mask, and pending signals.
.\"
.\" Traduzione by Ottavio G. Rizzo (otto@mast.queensu.ca)
.\" Luglio 1998
.\" Aggiornamento alla versione 1.27, febbraio 2000
.\" Aggiornamento a man-pages-2.15 di Giulio Daprelà <giulio@pluto.it>
.\" dicembre 2005
.\" Aggiornamento a man-pages-2.31 di Giulio Daprelà - maggio 2006
.\" Aggiornamento a man-pages-2.49 di Giulio Daprelà - giugno 2007
.\" Aggiornamento a man-pages-2.63 di Elisabetta Galli - luglio 2007
.\"
.TH SIGNAL 7  "21 dicembre 2007" "Linux" "Linux Programmer's Manual"
.SH NOME
signal \- elenco dei segnali disponibili
.SH DESCRIZIONE
Linux supporta sia i segnali POSIX affidabili (d'ora in avanti
"segnali predefiniti") che i segnali real-time POSIX.
.SS "Disposizioni dei segnali"
Ciascun segnale ha una
.IR disposizione
attuale, che determina come si comporta il processo
quando il segnale viene recapitato.

Le voci nella colonna "Azione" della tabella specificano
la disposizione predefinita del segnale, come segue:
.IP Term
L'azione di default è di terminare il processo.
.IP Ign
L'azione di default è di ignorare il segnale.
.IP Core
L'azione di default è di terminare il processo e fare un dump core (vedere
.BR core (5)).
.IP Stop
L'azione di default è di arrestare il processo.
.IP Cont
L'azione di default è di continuare il processo se esso è attualmente fermo.
.PP
Un processo può cambiare la disposizione di un segnale usando
.BR sigaction (2)
o (meno portabile)
.BR signal (2).
Usando queste chiamate di sistema, un processo può assumere uno dei
seguenti comportamenti al recapito del segnale: 
eseguire l'azione predefinita; ignorare il segnale; 
o intercettare il segnale con un
.IR "signal handler" , 
una funzione definita dal programmatore che è automaticamente
invocata quando il segnale è recapitato.

La disposizione del segnale è un attributo per processo:
in un'applicazione multithreaded, la disposizione di un
particolare segnale è la stessa per tutti i thread.
.SS "Maschera segnale e segnali pendenti"
Un segnale può essere
.IR bloccato ,
che significa che esso non verrà recapitato fino a quando non verrà sbloccato.
Un segnale viene definito
.IR pendente 
nel periodo di tempo che passa tra quando è stato generato e quando è recapitato.

Ciascun thread in un processo ha una
.IR "maschera segnale"
indipendente, che indica l'insieme di segnali che il thread attualmente sta bloccando.
Un thread può manipolare la sua maschera segnale usando
.BR pthread_sigmask (3).
In un'applicazione tradizionale a thread singolo, 
.BR sigprocmask (2)
può essere usato per manipolare la maschera segnale.

Un segnale può essere generato (e quindi pendente)
per un processo nel suo insieme (per esempio quando è inviato usando
.BR kill (2)) 
o per uno specifico thread (per esempio certi segnali, 
come
.B SIGSEGV
e
.BR SIGFPE ,
generati come conseguenza 
dell'esecuzione di una istruzione specifica in linguaggio macchina
è diretta al thread, come lo sono i segnali indirizzati a uno specifico thread usando
.BR pthread_kill (3)).
Un segnale diretto al processo può essere recapitato a uno qualunque dei
thread che attualmente non hanno il segnale bloccato.
Se più di uno dei thread ha il segnale sbloccato, allora il
kernel sceglie un thread arbitrario a cui recapitare il segnale.

Un thread può ottenere l'insieme di segnali che attualmente ha
pendenze usando
.BR sigpending (2).
Questo insieme consisterà nell'unione del set dei segnali diretti ai
processi pendenti e il set di segnali pendenti per il
thread chiamante.
.SS "Segnali standard"
Linux supporta i segnali standard elencati di seguito.
Molti numeri di segnale
dipendono dall'architettura, come indicato nella colonna "Valore"
(dove sono indicati tre valori, il primo è normalmente valido per
alpha e sparc, quello in mezzo per i386, ppc e sh, e
l'ultimo per mips.
A \- denota che un segnale è assente sulla corrispondente architettura).

Prima i segnali descritti nello standard POSIX.1-1990 originale.
.TS
l c c l
____
lB c c l.
Segnale	Valore	Azione	Commento
SIGHUP	\01	Term	La linea sul terminale che ha il controllo è stata
			agganciata o il processo che ha il controllo è morto
SIGINT	\02	Term	Interrupt da tastiera
SIGQUIT	\03	Core	Segnale d'uscita della tastiera
SIGILL	\04	Core	Istruzione illegale
SIGABRT	\06	Core	Segnale d'abbandono di \fIabort\fP(3)
SIGFPE	\08	Core	Eccezione di virgola mobile
SIGKILL	\09	Term	Termina il processo
SIGSEGV	11	Core	Riferimento di memoria non valido
SIGPIPE	13	Term	Pipe rotta: scrittura su una pipe priva di
			lettori
SIGALRM	14	Term	Segnale del timer da \fBalarm\fP(2)
SIGTERM	15	Term	Segnale di termine
SIGUSR1	30,10,16	Term	Segnale 1 definito dall'utente
SIGUSR2	31,12,17	Term	Segnale 2 definito dall'utente
SIGCHLD	20,17,18	Ign	Figlio fermato o terminato
SIGCONT	19,18,25	Cont	Continua se fermato
SIGSTOP	17,19,23	Stop	Ferma il processo
SIGTSTP	18,20,24	Stop	Stop digitato da tty
SIGTTIN	21,21,26	Stop	Input da tty per un processo in background
SIGTTOU	22,22,27	Stop	Output da tty per un processo in background
.TE

I segnali
.B SIGKILL
e
.B SIGSTOP
non possono essere intercettati, bloccati o ignorati.

Seguono i segnali che non sono nello standard POSIX.1-1990 ma sono descritti in
SUSv2 e POSIX.1-2001.
.TS
l c c l
____
lB c c l.
Segnale	Valore	Azione	Commento
SIGBUS	10,7,10	Core	Errore sul bus (accesso erroneo alla memoria)
SIGPOLL		Term	Evento suscettibile di polling (Sys V). Sinonimo di \fISIGIO\fP
SIGPROF	27,27,29	Term	Timer del profiler scaduto
SIGSYS	12,\-,12	Core	Argomento sbagliato alla routine (SVr4)
SIGTRAP	5	Core	Trappola per trace/breakpoint
SIGURG	16,23,21	Ign	Condizione urgente sul socket (4.2 BSD)
SIGVTALRM	26,26,28	Term	Allarme virtuale (4.2 BSD)
SIGXCPU	24,24,30	Core	Ecceduto tempo limite di CPU (4.2 BSD)
SIGXFSZ	25,25,31	Core	Limite dimensione file superato (4.2 BSD)
.TE

Fino a Linux 2.2 incluso, il comportamento predefinito per
.BR SIGSYS ", " SIGXCPU ", " SIGXFSZ ", "
e (su architetture diverse da SPARC e MIPS)
.B SIGBUS
era di terminare il processo (senza eseguire un core dump).
(In alcuni altri sistemi Unix l'azione di default per
.BR SIGXCPU " e " SIGXFSZ
è di terminare il processo senza eseguire un core dump.)
Linux 2.4 è conforme ai requisiti di POSIX 1003.1-2001 per questi segnali,
terminando il processo con un core dump.

E ora altri vari segnali.
.TS
l c c l
____
lB c c l.
Segnale	Valore	Azione	Commento
SIGIOT	6	Core	Trappola IOT. Sinonimo di \fBSIGABRT\fP
SIGEMT	7,\-,7	Term
SIGSTKFLT	\-,16,\-	Term	Errore dello stack del coprocessore (inutilizzato)
SIGIO	23,29,22	Term	I/O ora possibile (4.2 BSD)
SIGCLD	\-,\-,18	Ign	Sinonimo di \fBSIGCHLD\fP
SIGPWR	29,30,19	Term	Mancanza di corrente (System V)
SIGINFO	29,\-,\-		Sinonimo di \fBSIGPWR\fP
SIGLOST	\-,\-,\-	Term	Perso il lock del file
SIGWINCH	28,28,20	Ign	Dimensioni finestra cambiate (4.3 BSD, Sun)
SIGUNUSED	\-,31,\-	Term	Segnale inutilizzato (diventerà \fBSIGSYS\fP)
.TE

(Il segnale 29 è
.B SIGINFO
/
.B SIGPWR
su alpha ma
.B SIGLOST
su sparc.)

.B SIGEMT
non è specificato in POSIX.1-2001, tuttavia appare
in molti altri sistemi Unix,
dove la sua azione predefinita è tipicamente di terminare il
processo con un core dump.

.B SIGPWR
(non specificato in POSIX.1-2001) è tipicamente ignorato
in via predefinita in questi altri Unix dove appare.

.B SIGIO
(non specificato in POSIX.1-2001) è ignorato in via predefinita
in molti altri sistemi Unix.
.SS "Segnali Real-time"
Linux supporta i segnali real-time come originariamente definiti nelle
estensioni real-time di POSIX.1b (e ora incluse in POSIX.1-2001).
L'intervallo di segnali real-time supportati è definito dalle macro
.B SIGRTMIN
e
.BR SIGRTMAX .
POSIX.1-2001 richiede che un'implementazione supporti almeno
i segnali real-time
.B _POSIX_RTSIG_MAX .
.PP
Il kernel Linux supporta un intervallo di 32 diversi segnali
real-time, numerati da 33 a 64.
Comunque, l'implementazione di glibc POSIX dei thread usa internamente
due (per NTPL) o tre (per LinuxThreads) segnali real-time
(vedere
.BR pthreads (7)),
e sistemare il valore di
.B SIGRTMIN
in modo adatto (a 34 o 35).
Dato che l'intervallo di segnali real-time disponibili varia a seconda
dell'implementazione dei thread di glibc (e questa variazione può avvenire
al run-time in accordo con kernel e glibc disponibili),
e poiché l'intervallo dei segnali real-time varia tra i vari sistemi Unix,
i programmi
.IR "non dovrebbero riferirsi ai segnali real-time usando numeri prefissati" .
Dovrebbero invece sempre fare riferimento ai segnali real-time usando la notazione
.BR SIGRTMIN +n,
e includendo controlli adatti (run-time) perché
.BR SIGRTMIN +n
non ecceda
.BR SIGRTMAX .
.PP
Diversamente dai segnali predefiniti, i segnali real-time non hanno significati predefiniti:
l'intero insieme dei segnali real-time può essere usato per scopi definiti
dall'applicazione.
(Si noti, tuttavia, che l'implementazione LinuxThreads usa i primi tre
segnali real-time).
.PP
L'azione predefinita per i segnali real-time non gestiti è di terminare
il processo ricevente.
.PP
I segnali real-time sono distinti dal seguente:
.IP 1. 4
Istanze multiple di segnali real-time possono essere accodate.
Viceversa, se istanze multiple di un segnale predefinito sono consegnate
mentre questo segnale è bloccato, allora viene accodata solo un'istanza.
.IP 2. 4
Se il segnale è inviato usando
.BR sigqueue (2),
un valore di accompagnamento (che sia un intero o un puntatore) può 
essere inviato con il segnale.
Se il processo ricevente stabilisce un gestore per questo segnale usando il flag
.B SA_SIGINFO
a
.BR sigaction (2)
allora esso può ottenere questo dato attraverso il campo
.I si_value
della struttura
.I siginfo_t
passata come secondo argomento al gestore.
Inoltre i campi
.I si_pid
e
.I si_uid
di questa struttura possono essere usati per ottenere PID e
ID di un utente reale del processo che invia il segnale.
.IP 3. 4
I segnali real-time sono recapitati in un ordine garantito.
I segnali real-time multipli dello stesso tipo sono recapitati nell'ordine
in cui vengono inviati.
Se segnali real-time differenti sono inviati ad un processo, essi sono 
consegnati partendo dal segnale con il numero più basso.
(Cioè i segnali con i numeri bassi hanno la priorità maggiore).
.PP
Se sia i segnali predefinit che quelli real-time sono in attesa di un processo,
POSIX non specifica quale consegnare per primo.
Linux, come molte altre implementazioni, in questo caso dà priorità ai
segnali predefiniti.
.PP
conformemente a POSIX, un'implementazione deve permettere che almeno i segnali real-time
.B _POSIX_SIGQUEUE_MAX
vengano accodati a un
processo.
Tuttavia Linux fa le cose diversamente.
Nei kernel fino a e incluso il 2.6.7, Linux impone
un limite globale al numero di segnali real-time accodati
per tutti i processi.
Questo limite può essere visto e cambiato (con privilegi) attraverso
il file
.I /proc/sys/kernel/rtsig-max .
Un file correlato,
.IR /proc/sys/kernel/rtsig-nr ,
può essere usato per trovare quanti segnali real-time sono attualmente accodati.
In Linux 2.6.8, queste interfacce
.I /proc
sono sostituite dal limite di risorsa
.B RLIMIT_SIGPENDING
che specifica un limite per utente per i segnali accodati.
Vedere
.BR setrlimit (2)
per ulteriori dettagli.
.SS "Funzioni async-signal-safe"
.PP
Una routine di manipolazione dei segnali stabilita da
.BR sigaction (2)
o
.BR signal (2)
deve fare molta attenzione, poiché qualunque processo può essere interrotto
in un punto arbitrario durante l'esecuzione del programma.
POSIX ha il concetto di "funzione sicura".
Se un segnale interrompe l'esecuzione di una funzione non sicura, e
.I handler
chiama una funzione non sicura, allora il comportamento del programma non è definito
.
POSIX.1-2003 richiede all'implementazione di garantire che le seguenti
funzioni possano essere chiamate in sicurezza in un gestore di segnali:

.in +4
.nf
_Exit()
_exit()
abort()
accept()
access()
aio_error()
aio_return()
aio_suspend()
alarm()
bind()
cfgetispeed()
cfgetospeed()
cfsetispeed()
cfsetospeed()
chdir()
chmod()
chown()
clock_gettime()
close()
connect()
creat()
dup()
dup2()
execle()
execve()
fchmod()
fchown()
fcntl()
fdatasync()
fork()
fpathconf()
fstat()
fsync()
ftruncate()
getegid()
geteuid()
getgid()
getgroups()
getpeername()
getpgrp()
getpid()
getppid()
getsockname()
getsockopt()
getuid()
kill()
link()
listen()
lseek()
lstat()
mkdir()
mkfifo()
open()
pathconf()
pause()
pipe()
poll()
posix_trace_event()
pselect()
raise()
read()
readlink()
recv()
recvfrom()
recvmsg()
rename()
rmdir()
select()
sem_post()
send()
sendmsg()
sendto()
setgid()
setpgid()
setsid()
setsockopt()
setuid()
shutdown()
sigaction()
sigaddset()
sigdelset()
sigemptyset()
sigfillset()
sigismember()
signal()
sigpause()
sigpending()
sigprocmask()
sigqueue()
sigset()
sigsuspend()
sleep()
socket()
socketpair()
stat()
symlink()
sysconf()
tcdrain()
tcflow()
tcflush()
tcgetattr()
tcgetpgrp()
tcsendbreak()
tcsetattr()
tcsetpgrp()
time()
timer_getoverrun()
timer_gettime()
timer_settime()
times()
umask()
uname()
unlink()
utime()
wait()
waitpid()
write()
.fi
.in
.SH "CONFORME A"
POSIX.1
.SH BUG
.B SIGIO
e
.B SIGLOST
hanno lo stesso valore.
L'ultimo è commentato nel sorgente del kernel, ma il processo di
costruzione di alcuni software pensa ancora che
il segnale 29 sia
.BR SIGLOST .
.SH "VEDERE ANCHE"
.BR kill (1),
.BR kill (2),
.BR kill\%pg (2),
.BR set\%itimer (2),
.BR set\%rlimit (2),
.BR sget\%mask (2),
.BR sig\%action (2),
.BR sig\%nal (2),
.BR signalfd (2),
.BR sig\%pend\%ing (2),
.BR sig\%proc\%mask (2),
.BR sig\%queue (2),
.BR sig\%suspend (2),
.BR sig\%waitinfo (2),
.BR bsd\%_signal (3),
.BR raise (3),
.BR sig\%vec (3),
.BR sig\%set (3),
.BR str\%signal (3),
.BR sysv\%_signal (3),
.BR core (5),
.BR proc (5),
.BR pthreads (7)
.SH COLOPHON
Questa pagina fa parte del rilascio 2.78 del progetto
.I man-pages
di Linux.
Si può trovare una descrizione del progetto,
e informazioni su come riportare bachi,
presso
http://www.kernel.org/doc/man-pages/.
Per la traduzione in italiano si può fare riferimento a
http://www.pluto.it/ildp/collaborare/
