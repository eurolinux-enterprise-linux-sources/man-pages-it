.\" Copyright (c) 1998 Andries Brouwer
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" 2003-08-24 fix for / by John Kristoff + joey
.\"
.\" Traduzione by Ottavio G. Rizzo (otto@mast.queensu.ca)
.\" Luglio 1998
.\" Aggiornamento a man-pages-2.09 di Giulio Daprelà <giulio@pluto.it>
.\" ottobre 2005
.\" Aggiornamento a man-pages-2.62 di Elisabetta Galli <lab@kkk.it>
.\" luglio 2007
.\" Aggiornamento a man-pages-3.00 di Elisabetta Galli <lab@kkk.it>
.\" settembre 2008
.\"
.TH GLOB 7 "24 agosto 2003" "Linux" "Linux Programmer's Manual"
.SH NOME
glob \- Fare il globbing dei percorsi dei file
.SH DESCRIZIONE
Molto tempo fa, in Unix V6, c'era un programma
.I /etc/glob
che espandeva i modelli di metacaratteri.
Poco dopo venne incorporato nella shell.

Al giorno d'oggi c'è anche una routine di libreria
.BR glob (3)
che svolge la stessa funzione per un programma utente.

Le regole sono le seguenti (POSIX.2, 3.13).
.SS "Corrispondenze di metacaratteri"
Una stringa è un modello di metacaratteri se contiene uno dei
caratteri \(aq?\(aq, \(aq*\/aq o \(aq[\/aq.
Il globbing è l'operazione
che espande un modello di metacaratteri in un elenco di percorsi
che corrisponde al modello. Una
corrispondenza è definita da:

Un \(aq?\(aq (non fra virgolette) corrisponde ad un carattere singolo.

Un \(aq*\(aq (non fra virgolette) corrisponde a qualsiasi stringa, compresa
quella vuota.
.PP
.B "Classi di carattere"
.sp
Un'espressione nella forma "\fI[...]\fP"', in cui il primo carattere dopo la
\(aq[\(aq iniziale non è un \(aq!\(aq corrisponde ad un carattere singolo,
cioè a qualsiasi carattere fra quelli racchiusi tra le parentesi.
La stringa tra le parentesi non può essere vuota;
perciò è possibile avere una \(aq]\(aq fra parentesi, purché
essa sia il primo carattere
(perciò "\fI[][!]\fP" corrisponde ai
tre caratteri \(aq[\(aq, \(aq]\(aq e \(aq!\(aq).
.PP
.B Intervalli
.sp
C'è una convenzione speciale:
due caratteri separati da \(aq\-\(aq indicano un intervallo
(perciò "\fI[A\-Fa\-f0\-9]\fP"
equivale a "\fI[ABCDEFabcdef0123456789]\fP").
Si può includere un \(aq\-\(aq' col suo significato letterale ponendolo al
primo o all'ultimo posto fra le parentesi
(perciò "\fI[]\-]\fP" corrisponde solo ai due caratteri \(aq]\(aq e \(aq\-\(aq,
e "\fI[\-\-0]\fP" corrisponde ai
tre caratteri \(aq\-\(aq, \(aq.\(aq, \(aq0\(aq, dato che \(aq/\(aq
non ha corrispondenze).
.PP
.B Complementazione
.sp
Un'espressione "\fI[!...]\fP" corrisponde ad un carattere singolo, cioè a
qualsiasi carattere cui non corrisponda l'espressione ottenuta
rimuovendo il \(aq!\(aq iniziale
(perciò "\fI[!]a\-]\fP" corrisponde a
qualsiasi carattere singolo eccetto \(aq]\(aq, \(aqa\(aq e \(aq\-\(aq.).

Si può rimuovere il significato speciale di \(aq?\(aq, \(aq*\(aq e \(aq[\(aq
facendoli precedere da una backslash, o, nel caso l'espressione sia parte di
una riga di comando della shell, ponendoli fra virgolette doppie.
Fra parentesi quadre questi caratteri hanno un significato letterale.
Perciò "\fI[[?*\e]\fP" corrisponde ai
quattro caratteri \(aq[\(aq, \(aq?\(aq, \(aq*\(aq e \(aq\e\(aq.
.SS Percorsi
Il globbing si applica separatamente a ogni componente di un
percorso.
A uno \(aq/\(aq in un percorso non può corrispondere uno dei metacaratteri
\(aq?\(aq o \(aq*\(aq, né un intervallo come "\fI[.\-0]\fP".
Un intervallo non può contenere
uno \(aq/\(aq esplicito: il risultato sarebbe un errore di sintassi.

Se il nome di un file inizia con un \(aq.\(aq, deve esserci una
corrispondenza esplicita per il \(aq.\(aq
(perciò \fIrm\ *\fP non rimuove .profile, e \fItar\ c\ *\fP non
archivia tutti i file: \fItar\ c\ .\fP è meglio).
.SS "Elenchi vuoti"
La chiara e semplice regola precedente: "espandere un modello di metacaratteri
in un elenco di percorsi che corrisponde al modello» era la definizione
originale di Unix.
Permetteva modelli che si espandevano
in elenchi vuoti, come in
.br
.nf
	xv \-wait 0 *.gif *.jpg
.fi
quando, magari, non c'è nessun file *.gif (e questo non causa un
errore).
D'altra parte POSIX richiede che un modello di metacaratteri
non venga modificato se è sintatticamente sbagliato o se la lista dei
percorsi corrispondenti è vuota.
Con
.I bash
si può forzare il comportamento classico ponendo
.IR allow_null_glob_expansion=true .

(Problemi simili accadono in altri casi.
Per esempio, mentre script vecchi usano
.br
.nf
	rm \`find . \-name "*~"\`
.fi
per uno script nuovo bisogna usare
.br
.nf
	rm \-f nosuchfile \`find . \-name "*~"\`
.fi
per evitare messaggi di errore di
.I rm
invocato con un elenco vuoto di argomenti).
.SH NOTE
.SS Espressioni regolari
Si noti che i modelli di metacaratteri non sono espressioni regolari,
per quanto si assomiglino.
Prima di tutto corrispondono a
nomi di file piuttosto che a testo; inoltre le convenzioni
non sono le stesse: per esempio, \(aq*\(aq in un'espressione regolare significa zero o
più copie di quanto precede.

Ora che le espressioni regolari usano espressioni fra parentesi quadre
in cui la negazione è indicata con un \(aq^\(aq, POSIX ha dichiarato
indefinito l'effetto di un modello come "\fI[^...]\fP".
.SS Classi di carattere e internazionalizzazione
Naturalmente gli intervalli erano originariamente interpretati come intervalli
ASCII, per cui "\fI[\ \-%]\fP" stava per "\fI[\ !"#$%]\fP" e "\fI[a\-z]\fP" per
"una qualsiasi minuscola".
Alcune implementazioni Unix hanno generalizzato questo comportamento in modo tale
che l'intervallo X\-Y denoti l'insieme di caratteri i cui codici sono compresi
fra il codice di X e quello di Y.
Comunque ciò richiede che l'utente conosca
la codifica usata sul sistema locale, e, inoltre,
non è comodo quando la sequenza di collazione per l'alfabeto locale
è diversa dall'ordine dei codici di carattere.
Perciò POSIX ha notevolmente esteso la notazione parentetica,
sia per i modelli di metacaratteri che per le espressioni regolari.
Prima abbiamo visto tre tipi di argomenti che possono apparire in un'espressione parentetica:
vale a dire (i) la negazione, (ii) caratteri singoli espliciti
e (iii) intervalli.
POSIX definisce gli intervalli in un modo internazionalmente più
utile e aggiunge altri tre tipi:

(iii) Intervalli del tipo X\-Y che includono tutti i caratteri compresi tra X
e Y (inclusi) nella sequenza di collazione definita
dalla categoria
.B LC_COLLATE
nella localizzazione corrente.

(iv) Classi di carattere con nome, come
.nf

[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]
[:digit:]  [:graph:]  [:lower:]  [:print:]
[:punct:]  [:space:]  [:upper:]  [:xdigit:]

.fi
in modo da poter dire "\fI[[:lower:]]\fP" al posto di "\fI[a\-z]\fP" e ottenere il
risultato corretto anche in danese, dove ci sono tre lettere
nell'alfabeto che vengono dopo la \(aqz\(aq.
Queste classi di carattere sono definite dalla
categoria
.B LC_CTYPE
nella localizzazione corrente.

(v) Elementi di collazione, come "\fI[.ch.]\fP" o "\fI[.a-acute.]\fP, 
in cui la stringa compresa fra "\fI[.\fP" e "\fI.]\fP" è un elemento di collazione definito
dalla localizzazione corrente.
Si noti che questo può essere un
elemento composto da più caratteri.

(vi) Una classe di equivalenza, come "\fI[=a=]\fP",
in cui la stringa compresa tra "\fI[=\fP" e "\fI=]\fP" è un qualsiasi elemento
di collazione nella sua classe di equivalenza, come definita
dalla localizzazione corrente.
Per esempio, "\fI[[=a=]]\fP" potrebbe essere equivalente
.\" FIXME . i caratteri 'a' accentata non vengono visualizzati correttamente
.\" mtk maggio 2007
a "\fI[aáàäâ]\fP" (attenzione: questo è Latin-1), cioè a
"\fI[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]\fP".
.SH VEDERE ANCHE
.BR sh (1),
.BR fnmatch (3),
.BR glob (3),
.BR locale (7),
.BR regex (7)
.SH COLOPHON
Questa pagina fa parte del rilascio 3.00 del progetto
.I man-pages
di Linux.
Si può trovare una descrizione del progetto,
e informazioni su come riportare bachi,
presso
http://www.kernel.org/doc/man-pages/.
Per la traduzione in italiano si può fare riferimento a
http://www.pluto.it/ildp/collaborare/
